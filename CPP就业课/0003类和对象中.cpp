// 面向对象三大特性：


// 构造函数的特点
// 1.函数名与类名相同
// 2.没有返回值
// 3.对象实例化时系统会自动调用对应的构造函数
// 4.构造函数可以重载
// 5.

 
// 后定义的先析构 
// 有资源申请一定要写析构，否则会造成内存泄露



#include <iostream>

using namespace std;

class date
{
public:
	/*date(int year = 1, int month = 1, int day = 1)
	{
		_year = year;
		_month = month;
		_day = day;
	}*/

	void print()
	{
		cout << _year << "/" << _month << "/" << _day << endl;
	}

	bool operator==(date d2)
	{
		return _year == d2._year;
	}

private:
	int _year;
	int _month;
	int _day;
};

int main()
{
	date A;
	A.print();
	
	/*date B(2025, 7, 22);
	B.print();*/

	date B;
	A.operator==(B);
	A == B;

	return 0;
}



// 拷贝构造函数
// 如果一个构造函数的第一个参数是自身类类型的引用
// 且任何额外的参数都有默认值
// 则此构造函数也叫拷贝构造函数
// 也就是说拷贝构造是一个特殊的构造函数

// 特点
// 1.拷贝构造函数是构造函数的一个重载
// 
// 2.拷贝构造的第一个参数必须是类类型对象的引用，
//   使用传值方式编译器直接报错，因为语法逻辑上会引
//   发无限递归调用。
// 
// 3.C++规定自定义类型对象进行拷贝行为必须调用拷贝构造，
//   所以这里自定义类型传值传参和传值返回都会调用拷贝构造完成
//  C++规定传值传参必须调用拷贝构造
// 
// 4.若未显示定义拷贝构造，编译器会生成自动生成拷贝构造函数。
//   自动生成的拷贝构造对内置类型成员变量会完成值拷贝/浅拷贝(一个字节一个字节的拷贝)，
//   对自定义类型成员变量会调用他的拷贝构造


// 深拷贝 需要对指向资源创建同样大的资源再拷贝值

// 如果一个类显示实现了析构函数并释放了资源，
// 那么他就需要显示写拷贝构造，否则不需要
// 
// 调用拷贝构造
// Stack st2(st1);
// Stack st3 = st1;

// 6. 传值返回会产生一个临时对象调用拷贝构造，传值引用返回，
// 返回的是返回对象的别名(引用)，没有产生拷贝。但是如果返回对象是一个当前函数局部域的局部对象，
// 函数结束就销毁了，那么使用引用返回是有问题的，这时的引用相当于一个野引用，类似一个野指针一样。
// 传引用返回可以减少拷贝，但是一定要确保返回对象，在当前函数结束后还在，才能用引用返回。