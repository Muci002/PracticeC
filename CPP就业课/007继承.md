

##### 核心继承语法：class 子类名 : 继承方式 父类名（这里是public公有继承）；
继承是一种代码复用的方式
基类私有成员，派生类中不可见，语法上限制不能直接使用


```cpp
#include <iostream>
#include <string>
using namespace std;

// 基类（父类）：Person（人）
class Person 
{
public:
    // 基类属性
    string name;
    int age;

    // 基类方法
    Person(string n, int a) : name(n), age(a) {} // 构造函数
    void showBaseInfo() 
    {
        cout << "姓名：" << name << "，年龄：" << age << endl;
    }
};

// 派生类（子类）：Student（学生），公有继承（基类）Person， 继承方式 public
class Student : public Person 
{
public:
    // 子类特有属性
    int studentId; // 学号

    // 子类构造函数（必须先初始化父类构造）
    Student(string n, int a, int id) : Person(n, a), studentId(id) {}

    // 子类特有方法
    void showStudentInfo() 
    {
        // 复用父类的属性
        cout << "姓名：" << name << "，年龄：" << age << "，学号：" << studentId << endl;
    }
};

// 测试代码
int main()
{
    Student s("张三", 18, 2025001);
    // 调用父类的方法
    s.showBaseInfo();
    // 调用子类的方法
    s.showStudentInfo();
    return 0;
}
```






#### 多态
实现多态还有两个必须重要的条件
= 必须是基类的指针或者引用调用虚函数
= 被调用的函数必须是虚函数，并且完成了虚函数重写/覆盖

虚函数的重写/覆盖：派生类中有一个跟基类完全相同的虚函数（即派生类虚函数与基类虚函数的
返回值类型。函数名字。参数列表完全相同），称派生类的虚函数重写了基类的虚函数
virtual 只能修饰非静态的成员函数


```cpp
#include <iostream>

using namespace std;


/// <summary>

class Person
{
public:
	virtual void BuyTicket()
	{
		cout << "买票-全价" << endl;
	}
};

class Student : public Person
{
public:
	virtual void BuyTicket() override
	{
		cout << "买票-打折" << endl;
	}
};

void Func(Person* ptr)
{
	// 多态调用
	ptr->BuyTicket();
}



///////////////////////////////////////////////////////



class Animal
{
public:
	virtual void talk() const
	{ 
		cout << "吱吱" << endl;
	}
};

class cat : public Animal
{
public:
	virtual void talk() const
	{
		cout << "喵喵~" << endl;
	}
};

class dog : public Animal
{
public:
	virtual void talk() const
	{
		cout << "汪汪！" << endl;
	}
};

void letsHear(const Animal& animal)
{
	animal.talk();
}

// 实现多态的两个必须重要的条件：
// 必须是基类的指针或者引用调用虚函数
// 被调用的函数必须是虚函数，并且完成了虚函数重写/覆盖

int main()
{
	
	/*Person ps;
	Student st;
 	Func(&st);*/

	cat A;
	dog B;
	letsHear(A);
	letsHear(B);

	return 0;
}


// 多态时：重写是重写虚函数的实现部分
// 多态调用：父类虚函数声明 + 子类中的实现构成这个虚函数
// 普通调用看类型，多态调用看指向的对象
// 基类的虚构函数必须加virtual
//

// override 检查是否完成了重写
// final 不想构成重写

// 构造函数私有的类不能被继承
// C++11, final 修饰的基类不能被继承


```


