### 8. 贪心
贪心算法是两极分化很严重的算法。简单的问题会让你觉得理所应当，难一点的问题会让你怀疑人生。

### 1. 什么是贪心算法？
贪心算法，或者说是贪心策略：企图用局部最优找出全局最优。
1. 把解决问题的过程分成若干步；
2. 解决每一步时，都选择“当前看起来最优的”解法；
3. “希望”得到全局的最优解。

### 2. 贪心算法的特点
1. 对于大多数题目，贪心策略的提出并不是很难，难的是证明它是正确的。因为贪心算法相较于暴力枚举，每一步并不是把所有情况都考虑进去，而是只考虑当前看起来最优的情况。但是，局部最优并不等于全局最优，所以我们必须要能严谨的证明我们的贪心策略是正确的。
一般证明策略有：反证法，数学归纳法，交换论证法等等。
2. 当问题的场景不同时，贪心的策略也会不同。因此，贪心策略的提出是没有固定的套路和模板的。我们后面讲的题目虽然分类，但是大家会发现具体的策略还是相差很大。
因此，不要妄想做几道贪心题目就能遇到一个会一个。有可能做完 50 道贪心题目之后，第 51 道还是没有任何思路。

### 3. 如何学习贪心？
先有一个认知：做了几十道贪心的题目，遇到一个新的又没有思路，这时很正常的现象，把心态放平。
1. 前期学习的时候，重点放在各种各样的策略上，把各种策略当成经验来吸收；
2. 在平常学习的时候，我们尽可能的证明一下这个贪心策略是否正确，这样有利于培养我们严谨的思维。但是在比赛中，能想出来一个策略就已经不错了，如果再花费大量的时间去证明，有点得不偿失。这个时候，如果根据贪心策略想出来的若干个边界情况都能过的话，就可以尝试去写代码了。



--------------
--------------
--------------


### 3. 证明 ： 推公式
#### 数学知识：全序关系
1. **完全性（能够比大小）**
   - 对于元素 \(a\) 和 \(b\)，满足 \(a \leq b\) 或者 \(a \geq b\)。
2. **反对称性**
   - 对于元素 \(a\) 和 \(b\)，若 \(a \leq b\) 且 \(a \geq b\)，则 \(a = b\)。
   - 若 \(a\) 在 \(b\) 前且 \(b\) 在 \(a\) 前，那么 \(a\) 和 \(b\) 无所谓先后顺序。
3. **传递性**
   - 对于元素 \(a\)、\(b\) 和 \(c\)，若 \(a \leq b\) 且 \(b \leq c\)，则 \(a \leq c\)。
   - 若 \(a\) 在 \(b\) 前且 \(b\) 在 \(c\) 前，那么 \(a\) 在 \(c\) 前。




-----------
----
----


### 8.3 哈夫曼编码
#### 1. 树的带权路径长度
从树的根到任意结点的路径长度与该结点上权值的乘积，称为该结点的带权路径长度。树中所有叶结点的带权路径长度之和称为该树的带权路径长度，记为
\[
WPL = \sum_{i=1}^{n} w_i l_i
\]
其中，\( w_i \) 是第 \( i \) 个叶结点所带的权值，\( l_i \) 是该叶结点到根结点的路径长度。

#### 2. 哈夫曼树
在含有 \( n \) 个带权叶结点的二叉树中，其中带权路径长度最小的二叉树称为哈夫曼树，也称最优二叉树。

#### 3. 哈夫曼算法
哈夫曼算法是哈夫曼树的构建过程，是根据贪心策略得到的算法。主要流程为：
1. 初始化：将所有叶子结点看做一棵棵树，那么刚开始我们有一片森林；
2. 贪心：每次选择根节点权值最小的两棵树作为左右子树合并成一棵新的二叉树，这棵新的二叉树根节点的权值为左右子树的权值之和；
3. 重复 2 过程，直到森林中所有的树合并成一棵树。

在构建哈夫曼树的合并操作中，就可以计算出带权路径长度：
- 在合并的过程中，每一棵树的根节点的权值其实等于该树所有叶子结点的权值之和；
- 在每次合并的时候，由于多出来两条路径，此时累加上左右子树的根节点权值，相当于计算了一次叶子结点到这两条路径的长度；
- 每次合并都把左右子树的权值累加起来，就是最终的带权路径长度。




### 4. 哈夫曼编码
哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码，其构造步骤如下：
1. 统计待编码的序列中，每一个字符出现的次数；
2. 将所有的次数当成叶结点，构造哈夫曼树；
3. 规定哈夫曼树的左分支为 0，右分支为 1，那么从根节点走到叶子结点的序列，就是该叶子结点对应字符的编码。