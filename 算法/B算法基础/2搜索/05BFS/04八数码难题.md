**八数码难题** [P1379]

1. 如何剪枝？如何标记 3*3 的矩阵？
 把矩阵转换成字符串存储
<br>

2. 如何统计最短路
 unordered_map<string, int> dist;  
<br>

1. 二维坐标 &rarr; 一维坐标 . n*m 矩阵 
	1. 策略一：<span style="color:blue">不推荐</span>
   + 1.先把字符串转换成二维
   + 2.在二维矩阵的基础上，上下左右交换
   + 3.交换之后，再从矩阵还原成字符串
 <span style="color:red">缺点：</span>如果是n*m的矩阵，时间复杂度将会大大提高  
	2. 策略二：<span style="color:blue">推荐使用，注意下标必须从 0 开始计数</span>
   + 通过计算将一维坐标和二维坐标相互转换
   + 二维&rarr;一维
   + (x, y) &rarr; pos = xm + y
   + （x*m 表示上面有几个，y表示前面有几个）
   + 
   + 一维坐标 &rarr; 二维坐标
   + x = pos / m
   + y = pos % m
[![pZkv1Vx.png](https://s21.ax1x.com/2025/11/24/pZkv1Vx.png)](https://imgchr.com/i/pZkv1Vx)


```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <queue>

using namespace std;

string s;
unordered_map<string, int> dist;
int dx[] = { 0, 0, -1, 1 };
int dy[] = { 1, -1, 0, 0 };
string st = "123804765";

void bfs()
{
	if (s == st)
	{
		cout << 0;
		return;
	}
	dist[s] = 0;
	queue<string> q;
	q.push(s);

	while (q.size())
	{
		bool flag = false;
		string tmp = q.front(); q.pop();
		int t = 0;
		for (; t < tmp.size(); t++)
		{
			if (tmp[t] == '0') break;
		}
		int i = t / 3, j = t % 3;
		for (int k = 0; k < 4; k++)
		{
			int x = i + dx[k], y = j + dy[k];
			if (x < 0 || x >= 3 || y < 0 || y >= 3) continue;
			int pos = x * 3 + y;
			string str = tmp;
			swap(str[t], str[pos]);
			if (str == st)
			{
				cout << dist[tmp] + 1; 
				flag = true;
				break;
			}
			if (dist.count(str)) continue;
			dist[str] = dist[tmp] + 1;
			q.push(str);
		}
		if (flag) break;
	}

}

int main()
{
   	cin >> s;
	
	bfs();

	return 0;
}
```


[P1379]:https://www.luogu.com.cn/problem/P1379