// 单调栈解决的问题
// 单调栈能帮助我们解决以下四个问题：

// 寻找当前元素左侧，离它最近，并且比它大的元素在哪；
// 寻找当前元素左侧，离它最近，并且比它小的元素在哪；
// 寻找当前元素右侧，离它最近，并且比它大的元素在哪；
// 寻找当前元素右侧，离它最近，并且比它小的元素在哪。

// 虽然是四个问题，但是原理是一致的。因此，只要解决一个，举一反三就可以解决剩下的几个。

// 寻找当前元素左侧，离它最近，并且比它大的元素在
// 从左往右遍历元素，构造一个单调递减的栈。插入当前位置的元素的时：

// 如果栈为空，则左侧不存在比当前元素大的元素；
// 如果栈非空，插入当前位置元素时的栈顶元素就是所找的元素。

// 注意，因为我们要找的是最终结果的位置。因此，栈里面存的是每个元素的下标。

#include <iostream>
#include <stack>

using namespace std;
const int N = 3e6 + 10;
int a[N], n;

void test1()
{
	stack<int> st; // 维护一个单调递增的栈
	for (int i = 1; i <= n; i++)
	{
		// 栈里面大于等于 a[i] 的元素全部出栈
		while (st.size() && st.top() >= a[i]) st.pop();
		st.push(a[i]);
	}
}

void test2()
{
	stack<int> st; // 维护一个单调递减的栈
	for (int i = 1; i <= n; i++)
	{
		while (st.size() && st.top() <= a[i]) st.pop();
		st.push(a[i]);
	}
}

int main()
{

	return 0;
}