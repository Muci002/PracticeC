[P1955]

1. 数据范围很大，数据总量不大，利用离散化

```cpp
#include <iostream>
#include <unordered_map>
#include <algorithm>
#include <vector>

using namespace std;

struct node
{
	int x;
	int y; 
	int e;

};

// 离散化
int n;
vector<int> disc;

//int pos;
unordered_map<int, int> id;

// 并查集
vector<int> fa;

int find(int x)
{
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void un(int x, int y)
{
	fa[find(x)] = find(y);
}

bool issame(int x, int y)
{
	return find(x) == find(y);
}

vector<node> arr;

bool solve()
{
	id.clear();
	arr.clear();
	fa.clear();

	cin >> n;
	for (int i = 0; i < n; i++)
	{
		int x = 0, y = 0, e = 0;
		cin >> x >> y >> e;
		arr.push_back({x, y, e});
		disc.push_back(x);
		disc.push_back(y);
	}

	for (int i = 0; i < disc.size(); i++)
	{
		fa.push_back(i);
	}

	// 离散化
	sort(disc.begin(), disc.end());
	
	int cnt = 0;
	for (int i = 0; i < disc.size(); i++)
	{
		if (id.count(disc[i])) continue;
		
		id[disc[i]] = cnt;
		++cnt;
	}

	// 并查
	for (int i = 0; i < n; i++)
	{
		int x = arr[i].x, y = arr[i].y, e = arr[i].e;
		if (e) un(id[x], id[y]);
	}
	
	for (int i = 0; i < n;i++)
	{
		int x = arr[i].x, y = arr[i].y, e = arr[i].e;
		if (!e)
			if (issame(id[x], id[y]))
				return false;
	}

	return true;

}

int main()
{
	int T = 0; cin >> T;
	while (T--)
	{
		if (solve()) cout << "YES" << endl;
		else cout << "NO" << endl;
	}

	return 0;
}
```

[P1955]:https://www.luogu.com.cn/problem/P1955