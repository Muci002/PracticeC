3.2 并查集的概念
在有些问题中，我们需要维护若干个集合，并且基于这些集合要频繁执行下面的操作：
- 查询操作：查找元素x属于哪一个集合。一般会在每个集合中选取一个元素作为代表，查询的是这个集合中的代表元素；
- 合并操作：将元素x所在的集合与元素y所在的集合合并成一个集合；（注意，合并的是元素所在的集合，不是这两个元素！）
- 判断操作：判断元素x和y是否在同一个集合。
  

并查集(Union Find): 是一种用于维护元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，
树中的节点表示对应集合中的元素，根节点来代表整个集合


 ```
// 查询操作
int find(int x)
{
    if(fa[x] == x) return x;
    return fa[x] = find(fa[x]);  // 路径压缩

    // 一行实现
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}


// 合并操作
void un(int x, int y)
{
    int fx = find(x);
    int fy = find(y);
    fa[fx] = fy;
}


// 判断操作
bool issame(int x, int y)
{
    return find(x) == find(y);
}
 ```c



 // 初始状态下，所有元素单独成为一个集合
// 让元素自己指向自己即可
// 
// 查询操作
// 查询操作是并查集的核心操作，其余所有操作都是基于查询操作实现的
// 找到元素x所属的集合
// 一直向上找爸爸

// 并查集的优化
// 极端情况：在合并的过程中，整颗树变成一个链表
// 路径压缩，把被查询的节点到根节点的路径上所有节点的父节点设置为根节点，
// 从而减小树的深度。也就是说，在向上查询的同时，把在路径上的每个节点都
// 直接连接到根上，以后查询就能直接查询到根节点
int find(int x)
{
	if (find(fa[x]) == x) return x;
	return fa[x] = find(fa[x]);

	return find(fa[x]) == x ? x : fa[x] = find(fa[x]);
}

// 查询操作
int find(int x)
{
	if (fa[x] == x) return x;
	return find(fa[x]);
	// 一行实现
	return fa[x] == x ? x : find(fa[x]);
}

// 合并操作
// 将元素x所在的集合与元素y所在的集合合并成一个集合
// 让元素x所在的树的根节点指向元素y所在树的根节点

void un(int x, int y)// 函数名不能用union,因为他是c++的关键字
{
	int fx = find(x);
	int fy = find(y);
	fa[fx] = fy;
}

// 判断操作
// 判断元素x 和y是否在同一集合
// 看看两者所在的树的根节点是否相同

bool issame(int x, int y)
{
	return find(x) == find(y);
} 